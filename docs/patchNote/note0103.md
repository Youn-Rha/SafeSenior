# 01/03 일지
## Schedule
* 산학연 줌 미팅
* 클러스터링 문제 해결
* 클러스터링한 좌표에 모델 출력
* 3D 모델 대신하는 이미지 출력 기능 추가
* 배경 채색 기능 추가

## Visualizer Patch note
### 클러스터링 이상치
* 클러스터링 과정 중, 한 프레임의 전부가 이상치로 처리되는 케이스 발견, 해당 케이스가 에러를 야기함
    * 해당 케이스에 대한 대책으로, 이러한 경우 발생 시, 클러스터링 과정에서 이상치로만 구성된 프레임의 인덱스를 리스트로 리턴
    * 외부에서 이를 받아 abort 후, 해당 인덱스에 해당하는 프레임을 제거한 후, 데이터 수집을 계속하게 처리 구조 변경 필요
* 클러스터링 이상치 여부 판단 후, 이상치 없는 시퀸스 만들기 위해서는 기존 스레드 형식 변경이 필요
    * 시퀸스 완성 후, 전처리 포함한 AI 모델 구동하는 기존 시스템으로는 스레드 동기화 문제가 발생
    * 전처리 판별 이후 스레드 쉰다면 AI 모델 작동시키는 형식으로 구상 중
    * 기존 스레딩에서 사용하는 self.data는 스레드 구동중에 변화하기에 문제 가능성 존재
        * 파라미터로 전달하는 방식 사용해보자

### fall detection의 스레드 구성 재구성
* 기존 스레드 구성은 새로운 클러스터링 기법 적용에 걸림돌이기에 재설계 시도
* 기존 추론 과정을 스레드 내부로 옮김
* 모델 로드와 클러스터링만 잔류
* sequence만큼 모은 데이터에 대해 클러스터링 시도 후, 이상치 없다면 추론 스레드 시작
    * 이상치 있는 경우, 해당 데이터를 큐에서 없애서 abort
* 이상치가 MAX_SEQ_NOISE_LEN 이상 연속적으로 계속 들어오는 경우 deque 비움
    * deque의 경우 이 구현과 맞지 않아 리스트를 사용

### 3D 모델링을 이미지로 대체 및 배경 색칠 시도
* 3D 모델링을 이미지로 대체 하는 실험을 하기 위해 image_test.py 파일 생성
    * image_test.py 파일에서는 이미지를 정상적으로 불러올 수 있었지만, gui_threads.py에서는 오류가 발생
* 배경 색칠의 경우 현재 Visualizer의 박스 모델링은 선을 이용하여 면처럼 보이게 하는 것으로 실제로 면을 만들지는 않기 때문에 색칠 하는데 문제가 발생
    * 배경 색칠을 가능하게 하기 위해서는 모델링을 할 때 선을 사용하는게 아닌 면을 만들어야 함.
* 결론적으로, 이 두가지를 하기 위해서는 Visualizer의 3D 플로팅 방식 자체를 처음부터 고쳐야 하기에 실행하기 어려운 것으로 판단됨.

### 여러 클러스터에 맞는 추론 모델 인터페이스 변경
* 잘못된 running slot 체크기능 변경
* tid 사용하지 않는 모델로의 개선
    * 기존 tid 대신 클러스터가 판별하는 중심값 사용
    * 기존에 캐싱한 값을 각 인원별 중심값으로 대체
    * people tracking에 old_state 제외하고, 리턴형식을 변경
        * (val, prediction)
        * val이 True라면 추론 존재

### 긴 시퀸스 사용하는 클러스터에 맞는 기존 시스템 변경
* 15개 시퀸스 테스트
* 글로벌 클러스터링 이후 prepare_data 기능에 문제 발견
    * 글로벌 클러스터링 결과에서 AI 모델이 판별 가능한 길이 나오는지 판별
* 기존 AI 모델에서 이상한 평균 내는 시스템 확인
    * 고치는중

### 기타
* path를 매크로 상수 PATH 클래스에 정의
* AI 모델 관련 매크로 상수를 macroControl에 정의

## Replay 기능 개발 준비
* 다음 주 과제인 Replay 기능 개발을 준비하기 위해 여러 실험을 진행
* replay_test.py에 새로 개발한 함수들을 기록
    * initReplayBox는 프로그램 시작시 replay관련 UI를 초기화하는 함수로 레이아웃과 위젯의 위치는 변경할 가능성 높음
    * frameControl은 호출될 시 timer를 작동시켜 이미지를 캡쳐하도록 하는 함수
    * toggleReplay는 버튼을 누를 시 타이머가 정지/재개 되도록 하는 함수
    * capture_frame은 각 프레임을 이미지로 바꿔 리스트에 저장하면서 카운트를 1씩 늘리는 함수
    * get_frame은 리스트에서 인덱스에 맞는 프레임을 가져오는 함수로 아직 검증 안됨
* TODO
    * 센서 작동 시 frameControl을 호출하도록 변경 필요
    * 타임라인 슬라이더가 작동하도록 변경 필요
    * 리스트가 정상적으로 작동하는지 아직 확인되지 않음, 검증 필요

## 산학연 미팅
* 매주 목요일 패치노트를 aicoss에 업로드
* 다음주는 센서에 3D 모델 변화를 확인예정
* 1월 3째주 쯤 방문확인

## AI 모델
* 변환된 x,y,z 좌표와 길어진 10개 시퀸스로 모델 재학습

## TODO
* AI 모델 재학습
    * 시퀸스 길이 증가시킨 모델
    * 좌표계 변환
* AI 모델 : 좌표계 변환된 데이터에 대해 xyz 좌표 사용하는 길이 5 시퀸스의 모델 시도
* Visualizer 마무리
    * 클러스터에 모델 플로팅
    * 올라가는 인덱스 클러스터에 매핑 위한 시스템
        * 티켓 기반한 클러스터 캐싱 시스템
        * 오래된 클러스터 기록은 삭제하고 새로운 클러스터에 배정
        * 최대 길이 = 표시되는 사람 수
    * 현재 모델은 구면좌표계 사용하기에 좌표 변환이 필요


### 새로운 클러스터링 제안
* 기존 클러스터의 중심값과 카운터를 기록
    * 클러스터 n 번에 대해, 중심 좌표와 카운터 변수를 관리하는 각 리스트를 생성
* 클러스터 n번이 한 프레임에 포착된 경우
    1. 클러스터 중심값을 업데이트
    2. 클러스터 카운터를 1 증가
* 헝가리안이 작동할때
    * 기존 : a번 프레임의 중심값과 a + 1번 프레임의 중심값을 비교
    * 변형 : (a번의 프레임 중심값 + 기록한 중심값)과 a + 1번 프레임의 중심값을 비교
* 여기서 '기록한 중심값'은 n번 클러스터 기록에 대해 카운터가 3 이상인 경우만 사용
* 전체 로직
    [a번 프레임을 처리 시작]
    1. 기존 방식대로 한 프레임에 대한 클러스터를 찾는다
    2. 헝가리안을 돌린다 (a 프레임과 a-1 프레임 비교)
    3. 클러스터가 매핑된다. 연속되는 클러스터는 같은 번호, 불연속인건 새로운 번호로 (증가하는 형식)
    4. a 프레임에 모든 클러스터에 클러스터 번호가 지정되었으니, 각 클러스터 번호에 해당하는 카운터를 증가시키고, 각 번호에 해당하는 중심값도 업데이트 한다
    [a + 1번 프레임을 처리 시작]
    1. 기존 방식대로 한 프레임에 대한 클러스터를 찾는다
    2. 헝가리안을 돌린다 (a 프레임과 a + 1 프레임을 비교)
        * 여기서 a 프레임의 클러스터 중심값에 기존에 메모한 중심값을 추가하여 비교한다
        * 기존에 메모한 중심값은 모두 비교하지는 말고, 클러스터의 카운터가 3 이상일때만 a 프레임 클러스터 정보에 추가하여 사용한다

### run model 구조
* output
    * 클러스터 중심 좌표
    * 클러스터 번호
    * 자세
* 순서무관