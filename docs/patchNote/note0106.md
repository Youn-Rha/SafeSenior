# 01/06 일지
## 진행률
* 클러스터링의 한계 분석 [완료]
    * 긴 시퀸스 활용 (모델 적용시도 중)
    * 지도 클러스터링 학습
* Visualizer 재구현 [70%]
    * plotting 버그 해결 [완료]
        * 타이머 오버플로우 버그를 확인, 통합 스케쥴러 구현으로 해결
    * 좌표계 변환 문제 확인
        * AI 모델과 동시에 변환 시도 중
    * 의도되지 않은 AI 모델 구조 고치는 중
* global clustering 결과를 csv 파일에 반영 [완료]
* Replay 기능 구현 [10%]
    * 레이아웃 및 슬라이더 재생 기능 구현 시도 중
* 지도 클러스터링에 필요한 labeling tool 구현

## Schedule
* 재학습된 AI 모델의 적용 테스트
    * 시퀸스 길이 증가시킨 모델
        * 1초에 가까운 시퀸스의 경우 연속된 시퀸스 수집의 어려움
            * 지도 AI 통한 극복이 필요
    * 좌표계 변환
* 현재 적용중인 AI 모델 : 좌표계 변환된 데이터에 대해 xyz 좌표 사용하는 길이 5 시퀸스의 모델 시도
* Visualizer 마무리
    * 클러스터에 모델 플로팅
    * 올라가는 인덱스 클러스터에 매핑 위한 시스템
        * 티켓 기반한 클러스터 캐싱 시스템
        * 오래된 클러스터 기록은 삭제하고 새로운 클러스터에 배정
        * 최대 길이 = 표시되는 사람 수
    * 현재 모델은 구면좌표계 사용하기에 좌표 변환이 필요

## Visualizer Patch note
### fall detect의 추론 리턴형 결정
* (T/F, [ [(x,y,z), clust_num, state], ... ]) 형태
* 추론 없을 시 NO_PREDICT = (False, []) 리턴
* 스레딩 과정에서 문제점 발견
    * 빠른 시리얼 통신을 위해 wait 없는 스레드 사용
    * 결과가 리턴되지 않고 지나가기에 차후 스레드에서 리턴 필요
* 해당 구현에서 값의 전달이 잘 이루어지지 않고, 향후 클러스터링 결과에 플로팅 하는 모델 적용에 어려움 있다 판별

### 변경된 fall detect
* 클러스터링 결과에 따라 각 클러스터의 중심 좌표를 리턴
    * 캐싱 기능과, 캐싱 값과의 근사 여부에 따른 인원 할당 기능의 구현 필요
* 연속 클러스터 있을 시 추론
    * 기존 리턴 방식이 아닌 시그널 활용한 state 변경에 초점
    * 캐싱한 클러스터에 가까운 인원에 자세를 변경
* 리턴 기능 대신하는 시그널 및 함수 연결의 구현
    * predict 형태 변경 : [clust_num, state]의 연속
* slot running check 문제
    * 한 번 추론 후, 다음 추론 불가능한 현상
    * 시그널 구현으로 해결

### cartesian 기준의 내부 형식 변경
* Uart parse 후 outputDict를 fall detection 클래스에 받았을 때, 자체 기록하는 dataFrame의 이름을 Range, Azimuth, Elevation에서 xPos, yPos, zPos 로 변경
* AI 모델도 그에 맞는 cartesian 좌표를 사용하는 5 시퀸스 모델로 변경

### 단일 클러스터링
* 단일 클러스터 결과 리턴
    * 클러스터 연속과 무관하게 모델 plotting 위한 단일 클러스터의 중심좌표 리턴
    * 리턴 : (T/F, [ [clust_id_list], [x1, y1, z1], [x2, y2, z2], ... ])
* frame에 데이터 존재 시 한 프레임에 대한 클러스터링 시도 후, 각 클러스터 평균 좌표 리턴
* 처리 시간 너무 길다 : 프레임 당 200ms 전후
* 최적화 위해 z 좌표 삭제

### 단일 클러스터링 좌표 캐싱
* 판별된 클러스터에 대한 x, y 좌표 캐싱 후, 카운터 달아 일정 카운트 쌓이면 사용하는 방식 고려
* 너무 많은 클러스터링 확인되기에, DBSCAN의 min_samples를 기존 3개에서 40개로 증가
* 할당할 인원의 번호를 set으로 관리하며, 각 좌표는 리스트로 관리
* 각 요소에 대해 좌표 외에도 티켓 시스템 차용하여, 초기 티켓 전부 소진 시, 캐시 테이블에서 퇴출
* 최대 인원을 넘어서는 인원 파악 시, 가장 낮은 티켓 사용하는 요소에 overwrite
* 일정 threshold 이하의 거리에 존재하는 엔트리 파악 시, 해당 엔트리에 overwrite
    * 없다면 새로운 entry로 추가
* 3D 모델 플로팅 메서드에 파라미터 전달 구현

### 추론 스레드에 다시 글로벌 클러스터링 기능 합치기
* AI 추론시 느려지는 문제 확인 : 스레드 분리 검증 필요
    * 종합 클러스터링에서 느려지는 것으로 예상, 스레드 분리 필요

## 클러스터링 Patch Note (구현율 약 70퍼센트)
* 클러스터링 과정에 적은 양의 pointnum에 대해서는 괜찮은데 많은 양의 pointnum에 대해서 속도 매우 저하
    * cluster_data, cluster_single_frame 함수의 속도 개선이 필요하다고 추론
* 속도 개선을 위해 방법 4가지 제시
    * 판다스 자체 함수 -> 넘파이 함수로 변환
    * min_sample 파라미터를 늘려서 클러스터링 속도 개선
    * xyz 좌표는 특징에 대해 전처리가 필요 없다고 판단하여 전처리 코드 삭제
    * 데이터프레임을 복사해서 변수에 저장하는 부분을 최소화
* 첫 번째와 네 번째 방법은 속도 차이가 별로 나지 않아서 채택하지 않음
* 두 번째와 세 번째 방법을 사용하여 함수의 속도를 약 2배 개선함
* Replay 프로그앰에 사용할 xyz 컬럼을 추가한 엑셀 파일 제작
* 추론 스레드에 오래 걸리는 글로벌 클러스터링 파트를 다시 합침

### plotting 에러
* 잘못된 좌표에 찍히는 문제는 좌표 변환 의심됨
* 변환 매크로 상수 바꾸어 기능 정상화

## TODO
* stateTransition() 구현, 캐시 테이블에서 가까운 요소에 자세 업데이트
* 위치 많이 흔들리는 문제는 interploation 등의 기능 사용으로 업데이트 필요
    * 플로팅 위치 캐싱 + 최대 이동 정도 제한하는 것이 정석으로 보임

## Replay Patch note (현재 구현율 약 [50%])
* 실시간으로 센서 연결하여 구동하는 상황에서는 90% 정상 작동함.
    * 정지하였다가 다시 시작하는 경우 프로그램 죽음. 해결가능한지, 불가능한지 아직 모름.
    * 해당 코드들 replay_test.py에 모두 업데이트함.
* replay관련 필요한 레이아웃 대부분 탑재
    * 현재 타임슬라이더 부분은 아직 구현되지 않음. 다른 필요한 부분은 모두 구현함.
    * csv를 이용한 replay프로그램에도 동일하게 적용하면 될것으로 예상(위치는 달라질 수 있음)
* TODO
    * 타임슬라이더 구현
        * 실시간으로 타임슬라이더를 연동할 수 있는지 아직 모름. 먼저 csv를 이용한 프로그램에 구현해 보는게 좋을 것으로 예측됨.
    * csv를 이용한 replay프로그램
        * 실시간이 아닌 이미 만들어진 csv를 불러와서 3D plotting하고 replay할 수 있는 프로그램 구현 필요

## 클러스터링 Patch Note (구현율 약 70퍼센트)
* 클러스터링 과정에 적은 양의 pointnum에 대해서는 괜찮은데 많은 양의 pointnum에 대해서 속도 매우 저하
    * cluster_data, cluster_single_frame 함수의 속도 개선이 필요하다고 추론
* 속도 개선을 위해 방법 4가지 제시
    * 판다스 자체 함수 -> 넘파이 함수로 변환
    * min_sample 파라미터를 늘려서 클러스터링 속도 개선
    * xyz 좌표는 특징에 대해 전처리가 필요 없다고 판단하여 전처리 코드 삭제
    * 데이터프레임을 복사해서 변수에 저장하는 부분을 최소화
* 첫 번째와 네 번째 방법은 속도 차이가 별로 나지 않아서 채택하지 않음
* 두 번째와 세 번째 방법을 사용하여 함수의 속도를 약 2배 개선함
* Replay 프로그앰에 사용할 xyz 컬럼을 추가한 엑셀 파일 제작